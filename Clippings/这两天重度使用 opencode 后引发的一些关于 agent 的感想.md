---
title: "这两天重度使用 opencode 后引发的一些关于 agent 的感想"
source: "https://mp.weixin.qq.com/s/rY5yqB3TE0o7LcnC4vkfpQ"
author:
  - "[[dongxu]]"
published:
created: 2026-01-05
description: "这两天密集使用了 opencode + oh-my-opencode，在一个并不轻量的真实任务中，我对 Age"
tags:
  - "智能体系统"
  - "上下文工程"
  - "非中断流程"
  - "基础设施瓶颈"
abstract: "作者通过使用 opencode 完成复杂数据库项目的经历，阐述了当前 AI 编程智能体的核心优势在于上下文工程、稳定的工作流设计以及多模型协同，而非单一模型的能力，并指出基础设施的自动化是未来提升体验的关键。"
---
Original dongxu *2026年1月5日 06:06*

这两天密集使用了 opencode + oh-my-opencode，在一个并不轻量的真实任务中，我对 Agent 系统的理解发生了一次明显的变化。

我的任务很具体：

为 TiKV 重新实现一层兼容 PostgreSQL 协议的 SQL 层。能够跑起简单的测试，例如 dvdrental 的兼容性测试以及 TPCC。

这个任务相当于重写一遍 TiDB 的 SQL 层，我知道这个任务不容易，哪怕只是跑起来简单的 TPCC 我们就大概花了 2 个月的时间，注意这还是一个团队的工作。

最终的结果让我出了一身冷汗。成果在这里：https://github.com/c4pt0r/tipg，我就不展开说了。

我本来预想它能干，但是可能需要花很长时间以及很多调教，但是结果却惊出我一身冷汗：不到一个下午，烧掉了大概 100多万 token，因为我是各种 Agent 的 Pro Max 会员，甚至都没有额外花钱。。。

我第一次清晰地意识到： 写代码的成本已经几乎可以忽略不计了，哪怕是数据库，操作系统，编译器这样的复杂项目（对于 AI 来说这些其实算是简单项目）。

写一点这个旅程的体验。

## Context Engineering 并不是堆 Prompt

在切换到 opencode 之前，我已经重度使用过 Claude Code、Gemini Pro、Codex 这类工具。

从形态上看，它们都已经是 agentic loop + tool use 的 CLI。

坦率说，底层模型能力本身已经没有本质差距，都是各家的顶级模型。

但实际体验中，成品差异却非常明显。

原因并不在模型，而在 context engineering。大家总有一些幻觉，好像套壳没有技术含量似的，但是我的体验是这里面的门道大了去了。。。

真正有效的 context engineering，是把以下内容持续、结构化、稳定地注入系统中：

- 明确但不过度具体的目标（人）
- 清晰的计划（Agent）
- 工程边界与约束 （人）
- 历史决策与隐含假设 （Agent）
- 让模型在长上下文中不乱飞的稳定中间结构 （Agent）

例如，当我切换到 opencode + oh-my-opencode 后，模型还是同一个模型，但行为完全不同了。 同样是 agentic loop， 同样是 tool use， 复杂工程的交工质量却完全不在一个量级。

oh-my-opencode 里一个让我很舒服的设计是：

它并不执着于“用哪个最强模型”，相反它把多个一线模型组织进同一个工作流中。其实这个也不难想到，3 个臭皮匠顶过诸葛亮，况且 3 个诸葛亮

这带来的效果明显超过预期。

未来的上限，不一定来自更大的模型本身，而更可能来自： 多模型（最强的那档）协同 + context engineering + 稳定 loop 的整体设计。

## 不中断，比“更聪明”重要

另一个关键但常被忽略的点是：

不中断的体验（non-interruptive flow）。

很多 agent 系统在 “思考 → 执行 → 报错 → 等人确认” 之间频繁打断。 也就是上下文是存在的，但工作流是断裂的。

我目前通过 ralph-loop 来解决这个问题 ：让 agent 在一个稳定的 loop 中持续无限推进（燃烧 token），

人只在必要的位置介入（通常是最后验收），而不是被迫扮演“下一步指挥官”。

一旦中断减少，变化非常明显，首先是工程节奏开始接近真实连续开发，人的认知负担明显下降。其实 AI 目前已经足够聪明，工具也足够好用，效率的瓶颈在人。

## 给人的界面同样重要

同样是 TUI，opencode 的体验明显的比 CC 好，我觉得主要来自一个点：

而人需要的是掌控感（sense of control）。

好的体验是让人始终清楚：

- 系统现在在做什么（thinking 和 todo 的展示）
- 为什么这么做
- 我何时、以什么方式可以介入

一旦人被迫向 agent 发指令等结果， 体验一定是糟糕的。

真正好的 agent 系统，应该把复杂性留在代码和 loop 里，

把决策权、节奏感和信任感通过精心设计的界面交还给人。

## 当前最差的体验：Infra

如果一定要指出当前体验中最差的部分，

那仍然是 infra：

- sandbox / runtime 配置
- 数据库与依赖服务的启动
- 测试环境、fixture、数据准备
- 本地与 CI 的一致性

这些事情高度重复、上下文破碎、且极度不 agent-friendly。即使模型已经能把“写代码”这件事做到很好，一旦卡在 infra 上，节奏还是会被硬生生拖慢。

下一阶段真正决定体验上限的， 不是 opencode 这样的工具本身，

而是 opencode + infra abstraction。

当 sandbox、数据库、测试，CICD，都能作为一等上下文被系统管理，而不是一堆需要人手动 glue 的脚本时，agent 才能真正从“写代码的助手”， 进化成持续推进工程的系统。

## opencode for XXX，很快就会到来

程序员可以说是第一批感受到 AGI 到来的群体，不管我们愿不愿接受，职业写代码这件事情很快就不存在了，不过也不用过度担心，人类不用靠体力狩猎以后，现代的人类仍然会去健身房锻炼，作为一个爱好和思维游戏，古法编程会持续存在的。

但是从最近编程 Agent 迭代情况来看，我认为：

- Context engineering 是可迁移的
- 模型能力正在标准化
- More tokens, more intelligence

也就是同样的食材（LLM）配合不一样的厨子（Claude Code / Open Code），你会得到截然不同的效果。但是你本人的 init prompt （目的）也许并没变化。

我们很快会看到 opencode for XXX、opencode for YYY 这样的系统出现。

底层模型可以完全相同，但通过不同的上下文组织方式，它们会表现得像完全不同的专业系统。

那时“通用大模型是否足够强”将不再是关键问题，真正重要的是：

谁更懂得如何构建一个长时间可持续稳定工作的上下文。

继续滑动看下一个

我世界的源代码

向上滑动看下一个