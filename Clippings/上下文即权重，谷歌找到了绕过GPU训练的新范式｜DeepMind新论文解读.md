---
title: "上下文即权重，谷歌找到了绕过GPU训练的新范式｜DeepMind新论文解读"
source: "https://mp.weixin.qq.com/s/TQsCt3cnGUoP4rLfcy07Dw"
author:
  - "[[博阳]]"
published:
created: 2025-12-09
description: "《AI未来指北》论文解读专栏，以一线视角和最易懂的语言拆解顶会顶刊精华。"
tags:
  - "记忆系统"
  - "元推理"
  - "持续学习"
  - "范式革新"
abstract: "谷歌DeepMind的Evo-Memory研究提出了一种新范式，通过让冻结的大模型在推理时进行元推理、主动反思和重构记忆，使上下文具备了类似权重的动态调整能力，从而在不更新模型参数的情况下实现持续学习。"
---
Original 博阳 *2025年12月8日 11:56*

![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

*《AI未来指北》论文解读专栏，以一线视角和最易懂的语言拆解顶会顶刊精华。*

**文 ｜博阳**

**编辑 ｜郑可君**

如果说2024年是长文本的军备竞赛，那到了25年年末，随着自进化模型、持续学习成为模型下一步核心瓶颈，战场已经转到了对记忆能力的全面加强上。

而在这场战争中，Google DeepMind 左右出击，在一个月内发布了两篇论文，试图在两条截然不同的路线上攻克这一难题。

11月初，DeepMind 发布了关于 Nested Learning（嵌套学习） 的重磅研究，提出了 HOPE 架构。

这是一场典型的重工业革命，谷歌试图通过重构 Transformer 的底层，让AI拥有永久的长期记忆和临时的短期突触，让它从死的知识库记忆体，变成活体的学习者。

从价值上讲，作为第一个全开放权重的模型，它绝对称得上是一种范式革命。但要落地，得对现有的 AI 基础设施进行一场伤筋动骨的手术，旧模型是完全不兼容的。

然而，仅仅几周后，11月27日，DeepMind的另一个团队联合UIUC抛出了另一篇论文 **《Evo-Memory》** 。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ow6przZuPIEawec3XZB7jCHBxQHe1Dj5phhy8Aao00lBqDaKHfDhDZ3XibhJ5Z20hGdJYNusgUAb1I8icia7llGQw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1#imgIndex=1)

这篇论文没有试图去动哪怕一个模型参数，却找到了一条新路，赋予模型持续学习的能力。

它向整个行业提出了一个新可能： **一个被冻结的LLM大脑，能够通过不断反思和重构自己的记忆，表现得像是一个被训练过的模型。**

虽然看起来它没那么底层，但从工程和应用角度来讲，这无疑也是一场 **范式革新** 。

在过去，我们认为，上下文工程只是人类教 AI 做事的权宜之计。 但Evo-Memory证明了，当上下文具备了自我反思、自我修剪、自我沉淀的能力时，它就不再是静态的提示词，它变成了 **流动的权重** 。

具体来说，它意味着记忆不再是固定不变的上下文提示词，而是能够在推理过程中主动检索、修剪和重组的可编辑对象，就像神经网络中的权重参数一样可以动态调整和优化。

而且，靠着它，我们不需要等待遥远的架构重构，也能让模型持续学习。 通过 **元推理** ，我们现在就可以让那个参数冻结的AI，在每一次交互中生长出新的智慧。

![Image](https://mmbiz.qpic.cn/sz_mmbiz_png/ow6przZuPIEawec3XZB7jCHBxQHe1Dj5N0z9hjJIShTGUWrSsrLVujupsJH7G8B35w3BJMMqj7U3wQ7LQCmichQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1#imgIndex=2)

（一图读懂）

## 01

## RAG 的困境

说到AI的记忆系统，就绕不开RAG（检索增强生成）。

过去两年，RAG几乎成了大模型应用的标配。无论是客服机器人、代码助手还是知识问答系统，背后都离不开这套架构。

在很长一段时间里，RAG 被视为解决大模型健忘和幻觉的解药。它的逻辑简单粗暴：模型记不住私有数据？没关系，把数据切块存进向量数据库。用户问什么，我们就检索什么，喂给模型照着念。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ow6przZuPIEawec3XZB7jCHBxQHe1Dj5txBhmjOc2MiaVtvvUprY6UraIaR6MtjXlU8GElvUyDI8BMx6ARl37Wg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1#imgIndex=3)

然而一个可检索的笔记本，并不是记忆。因为 **记忆不是录像，而是压缩。**

传统的 RAG 系统就像是一个没有辨别能力的图书管理员，只管把所有的对话历史、操作日志一股脑地存进仓库。它不会学习，只会按关键字检索。

所以当你第一次问AI“如何解一元二次方程”，它会从知识库里检索到公式，给你正确答案。第一百次、第一千次，依然如此。它永远不会因为回答过一千次同类问题，就形成某种经验性的快速响应机制。

更可怕的是，它检索到的内容可能包含矛盾、过时或无关的信息，但它没有能力判断哪些记忆是有价值的，哪些是噪音。遇到同样的问题，系统检索到十条相关记录，其中三条是已解决的旧问题，两条是误报，剩下五条才真正有用。但RAG会把这十条一股脑塞给模型，让模型在混乱的信息中自己摸索。

这说明， 现有的记忆系统大多停留在 **对话回忆(Conversational Recall)** 的层面，它只记得说了什么，却不记得学到了什么。这种静态的、被动的召回机制，导致智能体在面对连续的任务流时，无法积累经验，只能机械地重复过去 。

**在这个范式下，RAG作为一个只增加不减少、只存储不反思的记忆库，最终注定会被噪音淹没。数据越多，RAG反而可能越多错。**

**02**

## 什么叫学习？就是给记忆加上反思的滤网

那怎么能让这些放在RAG里的信息更有用，更像学习？这里需要参考人类是如何变强的路径。如果在打游戏中，我们死于一次埋伏，下一次绝不会原样再死一次。人类会思考，会总结。

这就叫学习而来的 **熟练** 。学习的本质就是 **真正的记忆。它不是存储，而是筛选、组织和进化** 。

![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

论文设计了一个名为ReMem的框架，它的运作方式颠覆了传统RAG的检索和生成二段式流程。它引入了一个全新的维度 **Refine（优化）。** 在每次任务执行过程中，AI不再只是被动检索和应用记忆，而是主动评估、重组甚至修剪自己的记忆库。

在增加新记忆的过程中，模型会历遍这样几个步骤：

1. **经历：** 智能体在环境中执行任务（比如在 AlfWorld 里找东西）。
2. **反馈：** 环境告诉它是成功还是失败。
3. **元推理（Refine）：** 在存入记忆之前，智能体必须进行一次内省。系统会问它：“基于刚才的结果，哪一步是废话？哪一步是关键？如果你失败了，原因是什么？” 。
4. **沉淀：** 智能体执行 **Pruning（修剪）** 和 **Reorganizing（重组）** ，把 20 步的曲折探索，压缩成一句“直接去柜台找杯子”的黄金法则，存入数据库 。
![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

这不仅仅是加了一个步骤，这是赋予了智能体编辑自己大脑的权利。

这种机制的效果是立竿见影的。 在Alf World这个虚拟家居环境中，把冷藏过的西红柿放进微波炉这个任务，基准模型平均需要22.6步才能完成。而配备了ReMem的模型，只需要11.5步。 因为它学会了识别哪些过往任务的经验可以迁移，哪些细节差异需要警惕，从而少走了近一半的弯路。

![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

在ToolBench数据集上，配备经验检索的ExpRAG模型，API调用准确率从61%提升到73%。模型不仅学会了调用API，还学会了 **如何思考调用API。** 它能从过去失败的尝试中总结教训，从成功的案例中抽象策略。

![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

更有意思的是记忆修剪率的差异。在GPQA这种跨学科科学问答数据集上，模型会主动删除36.8%的记忆条目。因为这些记录来自不同领域，对当前问题没有参考价值。而在AIME数学竞赛数据集上，修剪率只有17.5%，因为数学题之间的解题策略往往是相通的。

![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**通过ReMem，RAG不再是那个只会照单全收的图书管理员，它学会了学习中最重要的部分，提纯和遗忘** 。 人类专家之所以高效，不是因为他们记住了所有细节，而是因为他们知道什么时候该忽略什么。 ReMem让AI通过记忆，获得了这种选择性注意的能力。

03

## 它带来的真正范式转变，是上下文即权重

如果说这个论文带来的只是上面所说的对RAG的升级，那它的价值似乎非常有限。

但它其实揭示了一个足以改变整个训练模式的转变。即 **上下文可以成为新的权重** （Context is the new Weight）。

在过去，我们认为只有通过反向传播（Backpropagation）修改了模型权重的参数，模型才算学到了东西。这就是训练、后训练、SFT等做的工作。一旦训练完成，模型就被"冻结"了，它在部署阶段不会再记住任何新东西，所有适应都通过调整输入的上下文来实现。

但过去的上下文工程本质上是人类教AI规则。我们精心设计少样本示例，编写详细的指令，试图通过上下文窗口向模型灌输正确的行为模式。这种上下文虽然确实可以改变模型的行为，但仍然是外部的、静态的，不会随着模型的使用而进化。

**但ReMem证明了，如果一个冻结的模型能够通过反思，不断重构输入给自己的上下文，那么上下文在数学效果上，就等同于权重。**

**之所以这么说，首先是因为上下文的积累实际上就是无监督训练。在这个新范式中，上下文不再是静态的规则不再依赖人类提供的标准答案。它自己在环境中试错，通过与环境的交互（Interactions），自己生成数据，并自我强化。**

其次，这个自我强化的方法也和训练过程非常相似。在一般的训练阶段，模型依靠 **梯度下降（Gradient Descent）** 降低错误路径的权重，提升正确路径的权重。而 ReMem 在推理阶段，则是通过对记忆的 **沉淀与修剪调节了其选择权重** ，完美复刻了这一过程。

比如，当模型在任务中失败，ReMem 通过元推理分析原因，会将失败路径标记为反面教材或直接修剪掉。在下一次检索中，这段被处理过的上下文会在注意力机制中产生强烈的抑制作用，迫使模型避开错误选项。这在效果上，等同于对该路径进行了 **RLHF（人类反馈强化学习）的负向惩罚** 。

而当模型总结出一条捷径并存入记忆，这条经验在未来的推理中会被高优召回，直接提升生成正确动作的概率。

论文中的数据也支撑了这一观点。在引入包含失败经验的数据集时，普通的 RAG 系统因为无法区分好坏，性能直接下降；而 ReMem 却能通过反思机制变废为宝，保持极高的成功率 。

**这证明了上下文已经具备了权重的核心属性：抗噪性、纠错性和泛化性。** 模型在没有更新任何参数的情况下，通过在记忆中沉淀经验，实现了行为的永久性矫正。

**在以后，我们也许不需要真的去算梯度，不需要更新参数。仅仅通过自然语言层面的反思和沉淀，就能让模型表现出好像被训练过一样的行为矫正。**

**元推理（Meta-Reasoning）是谷歌这篇论文的另一个重点概念。**

什么是元推理？在传统的 Chain-of-Thought (CoT) 中，模型是在推理任务本身。这依然是在做题。

**而ReMem 引入的元推理，是对推理过程的推理** 。它要求模型跳出任务本身，以第三视角的上帝视角审视刚才的思维链路，指出错误，提炼正确路径。

![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**这个逻辑本身并不是什么新鲜事。** 早在23年，就已经有人在研究相关的领域，提出了Reflexion架构，用来引导模型的元认知能力。今年，Karpathy也曾经多次讲过模型需要一个反思能力。而反思的过程，正是元推理。

这种能力此前之所以没有被充分利用，是因为以前的模型大多只是优秀的做题家，而缺乏成为出题人（评价指令）所需的深刻内省能力。ReMem 证明了，当今的 SOTA 模型（如 Gemini 2.5 和 Claude 3.7）已经具备了这种能力。 **它们不仅能生成答案，还能评价答案的质量，并将其转化为策略知识而非仅仅是事实知识。**

另外一个元推理在过去无法应用的原因，是 **策略知识的特殊属性。策略** 是由经验归纳出来的产物，比如游戏的技巧。这种知识绝不可能从单次经历中产生，必须有足够多的例子，才能归纳出一条策略。

在 Evo-Memory 之前，记忆系统往往是短视的。受限于上下文窗口或简单的检索逻辑，模型往往只能看到最近的一两次交互。它也许能记住刚才撞墙了，但它记不住上周、昨晚、大前天都撞墙了。

**没有足够多的例子，元推理就失去了燃料。**

ReMem 的成功，某种程度上是因为它利用了现代大模型对长上下文的处理能力和结构化记忆的积累，让模型终于凑齐了 **归纳策略所需的临界样本量** 。 **它让这种元推理能力变成了一种真正能起到远期效果的语义压缩算法。**

**这是使得上下文即权重成立的核心逻辑。**

**04**

## 系统2的完整拼图

这一范式的确立，让我们终于看清了下一代 AI 的完整形态。

最近大火的 **DeepSeek V3.2** 在工具使用中展示了行动前的 **规划能力，** 它会在调用 API 之前进行大量的思维链推导。而 **ReMem** 展示了行动后的 **反思能力，** 它会在任务结束后进行深度的复盘。

**这两者结合，构成了完整的系统 2思维闭环** 。以前我们认为 RAG 是外挂的硬盘，但现在它其实是个 **计算问题** 。 只有经过元推理（清洗、压缩、结构化后）的信息，才有资格进入上下文，进而在这个冻结的神经网络中扮演权重的角色。

Evo-Memory 告诉我们，我们不需要等到 Nested Learning 这种重型架构普及的那一天。只要底座模型足够聪明，能够理解反思的指令，我们现在就可以通过让模型在记忆中自我训练，实现某种程度上的 **AGI（通用人工智能）原型：** 一个参数不变，但智慧随时间持续生长的数字生命。

![图片](https://mp.weixin.qq.com/s/www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20fill-opacity='0'%3E%3Cg%20transform='translate(-249.000000,%20-126.000000)'%20fill='%23FFFFFF'%3E%3Crect%20x='249'%20y='126'%20width='1'%20height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**推荐阅读**

继续滑动看下一个

腾讯科技

向上滑动看下一个